% This is a script for test.

% sp_map = gen_sp(img, opts);
% post_sp_map = process_sp_map(sp_map);
% 
% saliency_map = manifold_ranking(img, opts);
% % Binary process with threshold generated by Otsu's method.
% binary_map = im2bw(saliency_map, multithresh(saliency_map));

% figure(1);
% imshow(saliency_map);
% figure(2);
% imshow(binary_map);

% get_proposals(images{3});

% img = im2double(rgb2gray(img));
% img = rgb2gray(im2double(img));
% imshow(img);

% videoIndex = 1;
% images = data_info{videoIndex}.data;
% img_num = length(images);
% thld = 10;
% for index = 2:img_num
%     diff = diff_between_images(images{index}, images{index - 1});
%     imshow(diff);
%     pause()
% end

videoIndex = 2;
imgIndex = 2;
images = data_info{videoIndex}.data;
img1 = images{imgIndex};
img2 = images{imgIndex + 1};
% Convert to diverse color space.
tic();
labImg1 = rgb2lab(img1);
ycbcrImg1 = rgb2ycbcr(img1);
hsvImg1 = rgb2hsv(img1);
t = toc();
fprintf('Convert image format in %f s.\n', t);
tic();
labImg2 = rgb2lab(img2);
ycbcrImg2 = rgb2ycbcr(img2);
hsvImg2 = rgb2hsv(img2);
t = toc();
fprintf('Convert image format in %f s.\n', t);

% Get proposals from image.
tic();
[prop1, box1] = get_proposals(img1);
t1 = toc();
fprintf('%d proposal(s) found in %f s.\n', length(prop1), t1);
tic();
[prop2, box2] = get_proposals(img2);
t2 = toc();
fprintf('%d proposal(s) found in %f s.\n', length(prop2), t2);

% Decalare constants.
max_prop_num = 100;

% Preallocate memory space.
prop_num1 = min(length(prop1), max_prop_num);
prop_num2 = min(length(prop2), max_prop_num);
prop_dist = zeros(prop_num1, prop_num2);
size_sim = zeros(prop_num1, prop_num2);
shape_sim = zeros(prop_num1, prop_num2);

lastHist = cell(prop_num1, 1);
size1 = zeros(prop_num1, 1);
thisHist = cell(prop_num2, 1);
size2 = zeros(prop_num2, 1);

% Calculate features for proposals in both images.
tic();
for index = 1:prop_num1
    prop = prop1{index};
    rgbHist = get_mask_hist(img1, prop);
    labHist = get_mask_hist(labImg1, prop);
    ycbcrHist = get_mask_hist(ycbcrImg1, prop);
    hsvHist = get_mask_hist(hsvImg1, prop);
    lastHist{index} = merge_hist_info(rgbHist, labHist, ycbcrHist, hsvHist);
    size1(index) = sum(prop(:));
end
for index = 1:prop_num2
    prop = prop2{index};
    rgbHist = get_mask_hist(img2, prop);
    labHist = get_mask_hist(labImg2, prop);
    ycbcrHist = get_mask_hist(ycbcrImg2, prop);
    hsvHist = get_mask_hist(hsvImg2, prop);
    thisHist{index} = merge_hist_info(rgbHist, labHist, ycbcrHist, hsvHist);
    size1(index) = sum(prop(:));
end
width1 = box1(:,3) - box1(:,1);
height1 = box1(:,4) - box1(:,2);
width2 = box2(:,3) - box2(:,1);
height2 = box2(:,4) - box2(:,2);
t = toc();
fprintf('Calculate features for %d proposals in img1 and %d proposals in img2 in %s s.\n', prop_num1, prop_num2, t);

tic();
for index1 = 1:prop_num1
    for index2 = 1:prop_num2
        prop_dist(index1, index2) = 0.5 * (sum((thisHist{index2} - lastHist{index1}) .^ 2 ./ (thisHist{index2} + lastHist{index1} + eps)));
        size_sim(index1, index2) = abs(size1(index1) - size2(index2)) / max(size1(index1), size2(index2));
        shape_sim(index1, index2) = abs((width1(index1) - width2(index2)) * (height1(index1) - height2(index2))) / (eps + abs(width1(index1) * height1(index1) - width2(index2) * height2(index2)));
    end
end
t = toc();
fprintf('Calculate %d * %d distance in %f s.\n', prop_num1, prop_num2, t);

rank_dist = prop_dist + size_sim + shape_sim;
[sortedDist, disIdx] = sort(rank_dist(:));
colIdx = ceil(disIdx / size(rank_dist, 1));
rowIdx = mod(disIdx - 1, size(rank_dist, 2)) + 1;

select_prop_num = 100;
for index = 1:select_prop_num
    index1 = rowIdx(index);
    index2 = colIdx(index);
    p1 = prop1{index1};
    b1 = box1(index1,:);
    subplot(1, 2, 1);
    show_op(img1, p1, b1);
    p2 = prop2{index2};
    b2 = box2(index2,:);
    subplot(1, 2, 2);
    show_op(img2, p2, b2);
    pause();
end